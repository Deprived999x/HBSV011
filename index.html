<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HBS Full Demo Application r010</title>
    <script type="module">
        import * as PromptGenerator from './app/hbsPromptGenerator-r010.js';
        import { T2IPreviewer } from './app/t2i-previewer.js';
        
        window.PromptGenerator = PromptGenerator; // Make it available globally
        
        // Initialize T2I Previewer when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const previewerContainer = document.getElementById('t2i-previewer-container');
            if (previewerContainer) {
                window.t2iPreviewer = new T2IPreviewer();
                window.t2iPreviewer.init(previewerContainer);
            }
        });
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .hbs-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .group-button {
            color: white;
            border: none;
            padding: 15px 20px;
            width: 100%;
            text-align: left;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }

        .group-button:hover {
            background-color: #2980b9;
        }

        .group-button.completed {
            background-color: #2ecc71;
        }

        .group-button.inactive {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .group-content {
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease-out;
        }

        .group-content.active {
            height: auto;
            transition: height 0.3s ease-in;
        }

        .parameter {
            border-bottom: 1px solid #eee;
            padding: 15px 20px;
            transition: all 0.3s;
        }

        .parameter h3 {
            margin-top: 0;
            color: #333;
        }

        .option {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .option:hover {
            border-color: #3498db;
            background-color: #f8f9ff;
        }
        
        .option.selected {
            border-color: #3498db;
            background-color: #ebf5fb;
        }

        .options-container {
            margin-left: 20px;
        }

        .completed-section {
            padding: 10px 20px;
            background-color: #e8f4f8;
            border-top: 1px solid #d1e6f1;
        }

        .completed-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #d1e6f1;
        }

        .completed-item:last-child {
            border-bottom: none;
        }

        .next-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 15px;
            font-weight: bold;
        }

        .next-button:hover {
            background-color: #2980b9;
        }
        
        .progress-indicator {
            height: 5px;
            background-color: #e0e0e0;
            margin-top: -2px;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            width: 0;
            transition: width 0.3s;
        }
        
        .chevron {
            transition: transform 0.3s;
        }
        
        .group-button.active .chevron {
            transform: rotate(180deg);
        }
        
        .hidden {
            display: none;
        }
        
        .option-label {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .option-description {
            margin-top: 12px;
            color: #666;
        }
        
        .description-label {
            font-weight: bold;
            color: #333;
            display: inline-block;
            width: 100px;
        }
        
        /* Fix: Target the actual content structure for "As Seen In" text using improved styling */
        .option-description div:nth-child(2) {
            font-weight: bold;
            /* Use a font stack that explicitly includes Arial Bold */
            font-family: "Arial Bold", "Arial Black", Arial, sans-serif;
            font-variant: normal;
        }
        
        /* Keep the label itself styled properly */
        .option-description div:nth-child(2) .description-label {
            color: #333;
        }

        .edit-button {
            background-color: #f39c12;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
        }

        .parameter-status {
            font-size: 12px;
            font-style: italic;
            color: #666;
            margin-bottom: 10px;
        }

        .parameter-description {
            margin-bottom: 15px;
            color: #333;
        }

        .modifiers-section {
            margin-top: 20px;
            border-top: 1px dashed #e0e0e0;
            padding-top: 15px;
        }

        .modifier {
            margin-bottom: 15px;
        }

        .modifier-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .modifier-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-left: 15px;
        }

        .modifier-option {
            padding: 5px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            cursor: pointer;
            background-color: #f9f9f9;
            transition: all 0.2s;
        }

        .modifier-option:hover {
            border-color: #3498db;
            background-color: #f0f7fc;
        }

        .modifier-option.selected {
            border-color: #3498db;
            background-color: #ebf5fb;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }

        .character-preview {
            margin-top: 20px;
            padding: 20px;
            background-color: #f0f7fc;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .character-summary-container {
            flex: 1;
            min-width: 300px;
        }
        
        .character-formats-container {
            flex: 1;
            min-width: 300px;
        }
        
        .scrollable-summary {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #d1e6f1;
            border-radius: 4px;
            padding: 10px;
            background-color: white;
            resize: vertical; /* Allows vertical resizing only */
            min-height: 100px;
            margin-bottom: 15px;
        }
        
        /* Adjust the tab content for new layout */
        .tab-content {
            max-height: 350px; /* Increased height to balance with summary */
        }
        
        /* Improve the appearance of the character-preview header */
        .section-header {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #d1e6f1;
            padding-bottom: 10px;
            color: #2c3e50;
            font-weight: bold;
        }
        
        /* Make resize handle more visible */
        .scrollable-summary::-webkit-resizer {
            background-color: #d1e6f1;
            border: 2px solid #3498db;
        }

        /* Group-specific colors */
        #group-1 {
            background-color: #3498db; /* Original blue for Group 1 */
        }
        
        #group-1:hover {
            background-color: #2980b9; /* Darker blue for hover */
        }
        
        #group-2 {
            background-color: #9b59b6; /* Purple for Group 2 */
        }
        
        #group-2:hover {
            background-color: #8e44ad; /* Darker purple for hover */
        }
        
        #group-3 {
            background-color: #e67e22; /* Orange for Group 3 */
        }
        
        #group-3:hover {
            background-color: #d35400; /* Darker orange for hover */
        }
        
        #group-4 {
            background-color: #16a085; /* Teal for Group 4 */
        }
        
        #group-4:hover {
            background-color: #138873; /* Darker teal for hover */
        }
        
        /* Completed state colors */
        #group-1.completed {
            background-color: #2ecc71; /* Green for completed state - keeping original */
        }
        
        #group-2.completed {
            background-color: #27ae60; /* Darker green for Group 2 completed */
        }
        
        #group-3.completed {
            background-color: #2ecc71; /* Green for Group 3 completed */
        }
        
        #group-4.completed {
            background-color: #27ae60; /* Darker green for Group 4 completed */
        }
        
        /* Inactive state colors - keep consistent gray */
        .group-button.inactive {
            background-color: #95a5a6; /* Keep existing gray for inactive state */
            cursor: not-allowed;
        }
        
        /* Progress bar colors to match group headers */
        #progress-1 {
            background-color: #3498db;
        }
        
        #progress-2 {
            background-color: #9b59b6;
        }
        
        #progress-3 {
            background-color: #e67e22;
        }
        
        #progress-4 {
            background-color: #16a085;
        }
        
        .composed-prompt-text {
            font-family: 'Courier New', monospace;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
            margin-bottom: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Styles for prompt tabs */
        .prompt-tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab-button {
            background-color: #f1f1f1;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            margin-right: 2px;
        }
        
        .tab-button:hover {
            background-color: #e0e0e0;
        }
        
        .tab-button.active {
            background-color: #3498db;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 15px;
            border: 1px solid #ddd;
            border-top: none;
            margin-bottom: 15px;
            background-color: white;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content pre {
            margin: 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .copy-content-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        
        .copy-content-button:hover {
            background-color: #2980b9;
        }

        /* Add new styles for the format buttons container */
        .format-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 10px;
            align-items: flex-start; /* Align items at the top */
        }

        .format-buttons-container button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            height: 36px; /* Standardize button height */
            line-height: 20px; /* Ensure text is vertically centered */
            box-sizing: border-box; /* Include padding in height calculation */
            display: flex; /* Use flexbox for content alignment */
            align-items: center; /* Center text vertically */
            justify-content: center; /* Center text horizontally */
            margin: 0; /* Remove any default margins to ensure consistent alignment */
        }

        .format-buttons-container button:hover {
            background-color: #2980b9;
        }

        .format-buttons-container .export-button {
            background-color: #27ae60;
        }

        .format-buttons-container .export-button:hover {
            background-color: #219653;
        }

        .random-button-container {
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .random-button {
            background-color: #9b59b6; /* Purple color matching Group 2 */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .random-button:hover {
            background-color: #8e44ad; /* Darker purple for hover state */
        }

        .random-button.active {
            background-color: #27ae60; /* Green when active (same as completed group) */
        }

        .random-speed {
            width: 150px;
            margin: 0 10px;
        }

        .format-buttons-container .save-button {
            background-color: #f39c12; /* Orange color */
        }

        .format-buttons-container .save-button:hover {
            background-color: #d35400;
        }

        .format-buttons-container .load-button {
            background-color: #9b59b6; /* Purple color */
        }

        .format-buttons-container .load-button:hover {
            background-color: #8e44ad;
        }

        .format-buttons-container .new-button {
            background-color: #16a085; /* Teal color */
        }

        .format-buttons-container .new-button:hover {
            background-color: #138873;
        }

        .character-name {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px dashed #d1e6f1;
            text-align: center;
            display: none; /* Hidden by default until a name is set */
        }
        
        /* Add styling for keyboard shortcuts help */
        .keyboard-shortcuts {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: right;
        }
        
        .keyboard-shortcuts kbd {
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 5px;
            font-family: monospace;
        }
        
        /* Add notification styling */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #27ae60;
            color: white;
            padding: 12px 20px;
            border-radius: 5px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Add these styles for the T2I Previewer error states */
        .t2i-error {
            padding: 15px;
            background-color: #fff0f0;
            border: 1px solid #ffcaca;
            border-radius: 4px;
            color: #e74c3c;
        }
        
        .t2i-error ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .t2i-error .t2i-prompt-used {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .t2i-loading {
            padding: 20px;
            text-align: center;
            color: #777;
        }
        
        .t2i-no-prompt {
            padding: 20px;
            text-align: center;
            color: #777;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>Human Build System - Full Demo r010</h1>
    <p>Create a character by selecting parameters across all four taxonomy groups. This is a full implementation using the complete HBS taxonomy.</p>
    
    <div class="character-preview">
        <!-- Left side: Character Summary -->
        <div class="character-summary-container">
            <h2 class="section-header">Character Summary</h2>
            <!-- Add character name display -->
            <div class="character-name" id="character-name-display"></div>
            <div class="scrollable-summary" id="character-summary">
                <p>No parameters selected yet. Begin by selecting options below.</p>
            </div>
        </div>
        
        <!-- Right side: Tab navigation for different formats -->
        <div class="character-formats-container">
            <h2 class="section-header">Output Formats</h2>
            <div class="prompt-tabs">
                <button class="tab-button active" data-tab="description">Description</button>
                <button class="tab-button" data-tab="t2i-prompt">T2I Prompt</button>
                <button class="tab-button" data-tab="t2i-preview">T2I Previewer</button>
                <button class="tab-button" data-tab="markdown">Markdown</button>
                <button class="tab-button" data-tab="json">JSON</button>
            </div>
            
            <!-- Tab content containers -->
            <div class="tab-content active" id="description-tab">
                <!-- Description will be populated here -->
            </div>
            <div class="tab-content" id="t2i-prompt-tab">
                <!-- T2I prompt will be populated here -->
            </div>
            <div class="tab-content" id="t2i-preview-tab">
                <div id="t2i-previewer-container"></div>
            </div>
            <div class="tab-content" id="markdown-tab">
                <pre id="markdown-content"></pre>
            </div>
            <div class="tab-content" id="json-tab">
                <pre id="json-content"></pre>
            </div>
            
            <!-- Button group for all format-related operations -->
            <div class="format-buttons-container">
                <button class="copy-content-button">Copy Current Prompt</button>
                <button class="copy-button" onclick="copyCharacter()">Copy Character Summary</button>
                <button class="save-button" onclick="saveCharacter()">Save Character</button>
                <button class="load-button" onclick="loadCharacter()">Load Character</button>
                <button class="new-button" onclick="newCharacter()">New Character</button>
            </div>
            
            <!-- Add keyboard shortcuts help -->
            <div class="keyboard-shortcuts">
                Shortcuts: <kbd>Ctrl+S</kbd> Save | <kbd>Ctrl+O</kbd> Load | <kbd>Ctrl+N</kbd> New
            </div>
        </div>
        
        <!-- Bottom: Random generator only -->
        <div style="width: 100%;">
            <div class="random-button-container">
                <button id="random-button" class="random-button" onclick="toggleRandomGeneration()">Auto-Random</button>
                <div>
                    <label>Speed: </label>
                    <input type="range" id="random-speed" class="random-speed" min="100" max="2000" step="100" value="500">
                    <span id="speed-value">0.5s</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hbs-container" id="main-container">
        <div class="loading">Loading taxonomy data...</div>
    </div>

    <!-- Add notification element -->
    <div class="notification" id="notification">Character saved successfully!</div>

    <script>
        // Global variables to store taxonomy data and character selections
        let taxonomyData = {};
        const selections = {};
        const completedParams = {};
        const modifierSelections = {};
        let paramGroups = {};
        let parameters = {};
        let groupStarts = {};
        let nextParam = {};
        let rules = { absoluteRules: [], suggestiveRules: [] }; // Store rules between parameters

        // Random character generation variables
        let isRandomGenerating = false;
        let randomTimer = null;
        let randomSpeed = 500; // ms
        let currentRandomGroup = 1;
        let currentParameterIndex = 0;

        // Load taxonomy data and rules from external files
        async function loadTaxonomyData() {
            try {
                console.log("Loading taxonomy data...");
                
                // Try different possible paths for the data files
                const possiblePaths = [
                    './data/',             // Root /data folder
                    './app/data/',         // /app/data folder
                    '../data/',            // One level up
                    './',                  // Same directory
                    '/HBSV010/data/'       // Absolute path with repo name
                ];
                
                let basePath = null;
                
                // First, try to find the correct path
                for (const path of possiblePaths) {
                    try {
                        console.log(`Trying path: ${path}`);
                        const testResponse = await fetch(`${path}hbs-taxonomy-g1-r010.json`, { method: 'HEAD' });
                        if (testResponse.ok) {
                            console.log(`Found working path: ${path}`);
                            basePath = path;
                            break;
                        }
                    } catch (e) {
                        console.log(`Path ${path} failed: ${e.message}`);
                    }
                }
                
                if (!basePath) {
                    console.error("Could not find data files in any of the expected locations");
                    throw new Error("Data files not found. Check your repository structure.");
                }
                
                // Now use the detected path to load all files
                const group1Response = await fetch(`${basePath}hbs-taxonomy-g1-r010.json`);
                if (!group1Response.ok) {
                    throw new Error(`Failed to load Group 1 data: ${group1Response.status}`);
                }
                const group1Data = await group1Response.json();
                
                const group2Response = await fetch(`${basePath}hbs-taxonomy-g2-r010.json`);
                if (!group2Response.ok) {
                    throw new Error(`Failed to load Group 2 data: ${group2Response.status}`);
                }
                const group2Data = await group2Response.json();
                
                const group3Response = await fetch(`${basePath}hbs-taxonomy-g3-r010.json`);
                if (!group3Response.ok) {
                    throw new Error(`Failed to load Group 3 data: ${group3Response.status}`);
                }
                const group3Data = await group3Response.json();
                
                const group4Response = await fetch(`${basePath}hbs-taxonomy-g4-r010.json`);
                if (!group4Response.ok) {
                    throw new Error(`Failed to load Group 4 data: ${group4Response.status}`);
                }
                const group4Data = await group4Response.json();
                
                // Also load the rules
                try {
                    const rulesResponse = await fetch(`${basePath}hbs-rules-r010.json`);
                    if (rulesResponse.ok) {
                        rules = await rulesResponse.json();
                        console.log(`Loaded ${rules.absoluteRules.length} absolute rules and ${rules.suggestiveRules.length} suggestive rules`);
                    } else {
                        console.warn("Could not load rules file. Using default rules.");
                    }
                } catch (rulesError) {
                    console.warn("Error loading rules:", rulesError);
                }
                
                // Combine all data into a single structure
                return {
                    "1": group1Data,
                    "2": group2Data, 
                    "3": group3Data,
                    "4": group4Data
                };
            } catch (error) {
                console.error("Error loading taxonomy data:", error);
                const container = document.getElementById('main-container');
                container.innerHTML = `
                    <div style="color: red; padding: 20px; background: #ffeeee; border: 1px solid red;">
                        <strong>Error loading taxonomy data:</strong> ${error.message}<br><br>
                        <strong>Troubleshooting:</strong>
                        <ul>
                            <li>Verify JSON files exist in the correct directory</li>
                            <li>We tried looking in: ./data/, ./app/data/, ../data/, ./, /HBSV010/data/</li>
                            <li>Check browser console for additional error details</li>
                            <li>Current URL: ${window.location.href}</li>
                        </ul>
                    </div>
                `;
                throw error;
            }
        }

        // Initialize the application after loading data
        async function initializeApp() {
            try {
                // Load taxonomy data and store it in the global variable
                taxonomyData = await loadTaxonomyData();
                
                // Initialize the application with the loaded data
                buildTaxonomyStructure();
                buildInterface();
                
                // Hide the "Bald" option
                hideSpecificOptions();

                // Check if gender is already set from a previous session
                if (selections[1] !== undefined) {
                    const genderOption = taxonomyData[1].parameters.find(p => p.id === 1).options[selections[1]];
                    const selectedGender = genderOption.name.toLowerCase();
                    handleFacialHairVisibility(selectedGender.includes('female'));
                }
            } catch (error) {
                console.error("Failed to initialize application:", error);
            }
        }

        // New function to hide specific options like "Bald"
        function hideSpecificOptions() {
            // Find the Hair Density parameter (ID 20)
            const hairDensityParam = document.getElementById('parameter-20');
            if (!hairDensityParam) return;
            
            // Get all options for Hair Density
            const options = hairDensityParam.querySelectorAll('.option');
            options.forEach(option => {
                const optionLabel = option.querySelector('.option-label');
                if (optionLabel && optionLabel.textContent.toLowerCase().includes('bald')) {
                    // Hide the bald option completely instead of just disabling it
                    option.style.display = 'none';
                    // Mark it as permanently disabled so it won't be chosen by random selection
                    option.classList.add('permanently-disabled');
                    console.log("Bald option has been hidden");
                }
            });
        }

        // Build parameter relationships and organization from taxonomy data
        function buildTaxonomyStructure() {
            // Build parameter groups mapping
            for (let groupNum = 1; groupNum <= 4; groupNum++) {
                const group = taxonomyData[groupNum];
                if (!group || !group.parameters) continue;
                
                // Set group start parameter
                if (group.parameters.length > 0) {
                    groupStarts[groupNum] = group.parameters[0].id;
                }
                
                // Map parameters to groups and build parameter names dictionary
                group.parameters.forEach((param, index) => {
                    paramGroups[param.id] = groupNum;
                    parameters[param.id] = param.name;
                    
                    // Set next parameter in sequence
                    if (index < group.parameters.length - 1) {
                        nextParam[param.id] = group.parameters[index + 1].id;
                    } else {
                        nextParam[param.id] = null; // Last parameter in group
                    }
                });
            }
        }
        
        // Build the UI based on taxonomy data
        function buildInterface() {
            const container = document.getElementById('main-container');
            container.innerHTML = ''; // Clear loading message
            
            // Create UI elements for each group
            for (let groupNum = 1; groupNum <= 4; groupNum++) {
                const group = taxonomyData[groupNum];
                if (!group) continue;
                
                // Create group section
                const groupSection = document.createElement('div');
                groupSection.id = `group-section-${groupNum}`;
                
                // Create group button
                const groupButton = document.createElement('div');
                groupButton.id = `group-${groupNum}`;
                groupButton.className = `group-button ${groupNum > 1 ? 'inactive' : ''}`;
                groupButton.onclick = () => toggleGroup(groupNum);
                groupButton.innerHTML = `
                    ${typeof group.group === 'string' ? group.group : (group.group && group.group.name ? group.group.name : `Group ${groupNum}`)}
                    <span class="chevron">â–¼</span>
                `;
                
                // Create progress indicator
                const progressIndicator = document.createElement('div');
                progressIndicator.className = 'progress-indicator';
                progressIndicator.innerHTML = `<div class="progress-bar" id="progress-${groupNum}"></div>`;
                
                // Create group content container
                const groupContent = document.createElement('div');
                groupContent.id = `content-${groupNum}`;
                groupContent.className = `group-content ${groupNum === 1 ? 'active' : ''}`;
                
                // Add parameters to group content
                group.parameters.forEach((param, index) => {
                    const paramElement = createParameterElement(param, index === 0 && groupNum === 1);
                    groupContent.appendChild(paramElement);
                });
                
                // Create completed section
                const completedSection = document.createElement('div');
                completedSection.id = `completed-${groupNum}`;
                completedSection.className = 'completed-section hidden';
                groupContent.appendChild(completedSection);
                
                // Assemble group section
                groupSection.appendChild(groupButton);
                groupSection.appendChild(progressIndicator);
                groupSection.appendChild(groupContent);
                
                // Add to container
                container.appendChild(groupSection);
            }
        }
        
        // Create UI element for a parameter
        function createParameterElement(param, visible = false) {
            const paramElement = document.createElement('div');
            paramElement.id = `parameter-${param.id}`;
            paramElement.className = `parameter ${visible ? '' : 'hidden'}`;
            
            // Add parameter header and description
            paramElement.innerHTML = `
                <h3>${param.id}. ${param.name}</h3>
                <div class="parameter-status">${param.status}</div>
                <div class="parameter-description">${param.description}</div>
            `;
            
            // Create options container
            const optionsContainer = document.createElement('div');
            optionsContainer.id = `options-${param.id}`;
            optionsContainer.className = 'options-container';
            
            // Add options
            param.options.forEach((option, index) => {
                // Special handling for Hair Color which has variants structure
                if (param.name === "Hair Color" && option.variants) {
                    // For each variant in the Hair Color option, create a separate option element
                    option.variants.forEach((variant, variantIndex) => {
                        const variantOptionElement = document.createElement('div');
                        variantOptionElement.className = 'option';
                        // When clicked, this needs to store both the parent option and the variant
                        variantOptionElement.onclick = () => selectOption(param.id, index, variantIndex);
                        
                        variantOptionElement.innerHTML = `
                            <div class="option-label">${option.name} - ${variant.name}</div>
                            <div class="option-description">
                                <div><span class="description-label">Visual:</span> ${variant.visual}</div>
                                <div><span class="description-label">As Seen In:</span> ${variant.as_seen_in}</div>
                            </div>
                        `;
                        
                        optionsContainer.appendChild(variantOptionElement);
                    });
                } else {
                    // Standard options for other parameters
                    const optionElement = document.createElement('div');
                    optionElement.className = 'option';
                    optionElement.onclick = () => selectOption(param.id, index);
                    
                    // For all other parameters with standard structure
                    const visual = option.visual || option.description || option.Visual || option.Description || "";
                    const asSeenIn = option.asSeenIn || option.as_seen_in || option.AsSeenIn || option["As Seen In"] || "";
                    
                    optionElement.innerHTML = `
                        <div class="option-label">${option.name || "Unnamed Option"}</div>
                        <div class="option-description">
                            <div><span class="description-label">Visual:</span> ${visual}</div>
                            <div><span class="description-label">As Seen In:</span> ${asSeenIn}</div>
                        </div>
                    `;
                    
                    optionsContainer.appendChild(optionElement);
                }
            });
            
            // Add modifiers if present
            if (param.modifiers) {
                const modifiersSection = document.createElement('div');
                modifiersSection.className = 'modifiers-section';
                modifiersSection.innerHTML = '<h4>Modifiers</h4>';
                
                // Handle object-style modifiers (as in your JSON files)
                if (!Array.isArray(param.modifiers)) {
                    Object.entries(param.modifiers).forEach(([modName, modOptions]) => {
                        const modifierElement = document.createElement('div');
                        modifierElement.className = 'modifier';
                        
                        // Add modifier name
                        const modifierName = document.createElement('div');
                        modifierName.className = 'modifier-name';
                        modifierName.textContent = modName;
                        modifierElement.appendChild(modifierName);
                        
                        // Add modifier options
                        const modifierOptions = document.createElement('div');
                        modifierOptions.className = 'modifier-options';
                        
                        modOptions.forEach((option, optIndex) => {
                            const modOptionElement = document.createElement('div');
                            modOptionElement.className = 'modifier-option';
                            modOptionElement.textContent = option.name;
                            modOptionElement.onclick = () => selectModifier(param.id, modName, optIndex);
                            modifierOptions.appendChild(modOptionElement);
                        });
                        
                        modifierElement.appendChild(modifierOptions);
                        modifiersSection.appendChild(modifierElement);
                    });
                } else {
                    // Original code for array-style modifiers
                    param.modifiers.forEach(modifier => {
                        const modifierElement = document.createElement('div');
                        modifierElement.className = 'modifier';
                        
                        // Add modifier name
                        const modifierName = document.createElement('div');
                        modifierName.className = 'modifier-name';
                        modifierName.textContent = modifier.name;
                        modifierElement.appendChild(modifierName);
                        
                        // Add modifier options
                        const modifierOptions = document.createElement('div');
                        modifierOptions.className = 'modifier-options';
                        
                        modifier.options.forEach((option, optIndex) => {
                            const modOptionElement = document.createElement('div');
                            modOptionElement.className = 'modifier-option';
                            modOptionElement.textContent = option.name;
                            modOptionElement.onclick = () => selectModifier(param.id, modifier.name, optIndex);
                            modifierOptions.appendChild(modOptionElement);
                        });
                        
                        modifierElement.appendChild(modifierOptions);
                        modifiersSection.appendChild(modifierElement);
                    });
                }
                
                optionsContainer.appendChild(modifiersSection);
            }
            
            // Add next button
            const nextButton = document.createElement('button');
            nextButton.className = 'next-button';
            nextButton.textContent = 'Next';
            nextButton.onclick = () => completeParameter(param.id);
            optionsContainer.appendChild(nextButton);
            
            paramElement.appendChild(optionsContainer);
            return paramElement;
        }
        
        // Toggle group expansion - modified to allow completed groups to always be toggled
        function toggleGroup(groupNum) {
            // Only prevent toggling groups marked as inactive AND not completed
            const groupButton = document.getElementById(`group-${groupNum}`);
            if (groupButton.classList.contains('inactive') && !groupButton.classList.contains('completed')) {
                return;
            }
            
            // Toggle the group content visibility
            const content = document.getElementById(`content-${groupNum}`);
            content.classList.toggle('active');
            
            // Toggle the chevron icon
            groupButton.classList.toggle('active');
        }
        
        // Handle parameter completion - ensure all groups close and slide to bottom when complete
        function completeParameter(paramId) {
            // Check if an option is selected
            if (selections[paramId] === undefined) {
                alert('Please select an option first');
                return;
            }
            
            const groupNum = paramGroups[paramId];
            const parameter = taxonomyData[groupNum].parameters.find(p => p.id === paramId);
            
            let selectedOption, optionLabel, visual, seenIn;
            
            // Handle Hair Color with variants
            if (parameter.name === "Hair Color" && typeof selections[paramId] === 'object') {
                const mainOption = parameter.options[selections[paramId].mainColorIndex];
                const variant = mainOption.variants[selections[paramId].variantIndex];
                
                selectedOption = variant;
                optionLabel = `${mainOption.name} - ${variant.name}`;
                visual = variant.visual;
                seenIn = variant.as_seen_in;
            } else {
                // Standard option handling
                selectedOption = parameter.options[selections[paramId]];
                optionLabel = selectedOption.name;
                visual = selectedOption.visual;
                seenIn = selectedOption.asSeenIn;
            }
            
            // Store completion with modifiers
            completedParams[paramId] = {
                value: optionLabel,
                visual: visual,
                seenIn: seenIn,
                modifiers: modifierSelections[paramId] || {}
            };
            
            // Update completed section
            const completedSection = document.getElementById(`completed-${groupNum}`);
            
            // Clear any existing item for this parameter (in case it's being re-edited)
            const existingItem = document.getElementById(`completed-item-${paramId}`);
            if (existingItem) {
                existingItem.remove();
            }
            
            // Create completed item with edit button
            const completedItem = document.createElement('div');
            completedItem.id = `completed-item-${paramId}`;
            completedItem.className = 'completed-item';
            
            // Get modifier info for display
            let modifierText = '';
            if (modifierSelections[paramId]) {
                const modifierEntries = Object.entries(modifierSelections[paramId]);
                if (modifierEntries.length > 0) {
                    modifierText = ' (';
                    modifierEntries.forEach(([modName, modIndex], idx) => {
                        // Access the modifier by property name directly, not using .find()
                        if (parameter.modifiers && parameter.modifiers[modName]) {
                            const modOptions = parameter.modifiers[modName];
                            if (modOptions && modOptions[modIndex]) {
                                modifierText += `${modOptions[modIndex].name}${idx < modifierEntries.length - 1 ? ', ' : ''}`;
                            }
                        }
                    });
                    modifierText += ')';
                }
            }
            
            completedItem.innerHTML = `
                <div><strong>${paramId}. ${parameter.name}:</strong> ${optionLabel}${modifierText}</div>
                <div><button class="edit-button" onclick="editParameter(${paramId})">Edit</button></div>
            `;
            
            completedSection.appendChild(completedItem);
            completedSection.classList.remove('hidden');
            
            // Calculate group progress
            const groupParams = Object.keys(paramGroups).filter(key => paramGroups[key] === groupNum);
            const totalParamsInGroup = groupParams.length;
            const completedParamsInGroup = Object.keys(completedParams)
                .filter(key => paramGroups[key] === groupNum).length;
            
            const progress = (completedParamsInGroup / totalParamsInGroup) * 100;
            document.getElementById(`progress-${groupNum}`).style.width = `${progress}%`;
            
            // Check if this was the last parameter in the group
            const next = nextParam[paramId];
            
            if (next && document.getElementById(`parameter-${next}`)) {
                // Hide the current parameter
                document.getElementById(`parameter-${paramId}`).classList.add('hidden');
                
                // Check if the next parameter is Facial Hair and we need to auto-complete it for females
                const nextParamElement = document.getElementById(`parameter-${next}`);
                if (nextParamElement && nextParamElement.classList.contains('gender-hidden')) {
                    // This is the Facial Hair parameter and it's hidden for females
                    console.log("Auto-completing facial hair parameter for female character");
                    
                    // Auto-complete the facial hair parameter
                    completedParams[next] = {
                        value: "None (Female character)",
                        visual: "Not applicable for female characters",
                        seenIn: "",
                        modifiers: {}
                    };
                    
                    // Update completed section for facial hair
                    const facialHairParam = taxonomyData[groupNum].parameters.find(p => p.id === next);
                    if (facialHairParam) {
                        const facialHairItem = document.createElement('div');
                        facialHairItem.id = `completed-item-${next}`;
                        facialHairItem.className = 'completed-item';
                        facialHairItem.innerHTML = `
                            <div><strong>${next}. ${facialHairParam.name}:</strong> None (Female character)</div>
                            <div><button class="edit-button" onclick="editParameter(${next})">Edit</button></div>
                        `;
                        completedSection.appendChild(facialHairItem);
                    }
                    
                    // Skip to the parameter after facial hair in the group (after facial hair)
                    const afterFacialHair = nextParam[next];
                    if (afterFacialHair && document.getElementById(`parameter-${afterFacialHair}`)) {
                        // Show the parameter after facial hair
                        document.getElementById(`parameter-${afterFacialHair}`).classList.remove('hidden');
                    } else {
                        // This was the last parameter in the group, complete group 3 and move to group 4
                        handleGroupCompletion(groupNum); // Complete the group and move to Group 4
                    }
                } else {
                    // Standard case - show the next parameter
                    nextParamElement.classList.remove('hidden');
                }
            } else {
                // This was the last parameter in the group
                document.getElementById(`parameter-${paramId}`).classList.add('hidden');
                // Complete the group and move to the next one
                handleGroupCompletion(groupNum);
            }
            
            // Apply all rules after completion, but don't disable parameters in completed groups
            setTimeout(() => {
                applyAllRulesWithCompletedGroups();
            }, 500);
            
            // Update character summary
            updateCharacterSummary();
        }
        
        // Helper function to handle group completion
        function handleGroupCompletion(groupNum) {
            document.getElementById(`group-${groupNum}`).classList.add('completed');
            
            // Close this group's accordion since it's completed
            const content = document.getElementById(`content-${groupNum}`);
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                document.getElementById(`group-${groupNum}`).classList.remove('active');
            }
            
            // Move completed group to the bottom
            const groupSection = document.getElementById(`group-section-${groupNum}`);
            const container = document.getElementById('main-container');
            
            // Add a transition for smooth visual movement
            groupSection.style.transition = 'opacity 0.3s ease-out';
            groupSection.style.opacity = '0.5';
            
            setTimeout(() => {
                // Move the group section to the end of the container
                container.appendChild(groupSection);
                
                // Animate it back in
                setTimeout(() => {
                    groupSection.style.opacity = '1';
                    
                    // Remove the transition after animation completes
                    setTimeout(() => {
                        groupSection.style.transition = '';
                    }, 300);
                }, 50);
            }, 300);
            
            // Activate next group
            if (groupNum < 4) {
                const nextGroupNum = groupNum + 1;
                
                // Debug which group we're activating
                console.log(`Activating next group: Group ${nextGroupNum}`);
                const nextGroupButton = document.getElementById(`group-${nextGroupNum}`);
                nextGroupButton.classList.remove('inactive');
                
                // Show the first parameter of next group
                const nextGroupStart = groupStarts[nextGroupNum];
                if (nextGroupStart) {
                    const nextGroupFirstParam = document.getElementById(`parameter-${nextGroupStart}`);
                    if (nextGroupFirstParam) {
                        nextGroupFirstParam.classList.remove('hidden');
                    }
                }
                
                // Explicitly ensure we're opening the next group in sequence
                for (let i = 1; i <= 4; i++) {
                    const content = document.getElementById(`content-${i}`);
                    const button = document.getElementById(`group-${i}`);
                    
                    if (i === nextGroupNum) {
                        // Open the next group
                        content.classList.add('active');
                        button.classList.add('active');
                    } else if (i !== groupNum) {
                        // Keep other groups (except completed one) in their current state
                        // Don't change their state here
                    }
                }
            } else {
                // All done! - Now all groups should remain clickable after completion
                alert('Character creation complete!');
                
                // Make sure all groups remain clickable after completion AND turn all bars green
                for (let i = 1; i <= 4; i++) {
                    const groupBtn = document.getElementById(`group-${i}`);
                    if (groupBtn) {
                        // Remove inactive state
                        if (groupBtn.classList.contains('inactive')) {
                            groupBtn.classList.remove('inactive');
                        }
                        
                        // Add completed state to all groups to turn them green
                        if (!groupBtn.classList.contains('completed')) {
                            groupBtn.classList.add('completed');
                        }
                    }
                }
                
                // Disable the Auto-Random button since character is complete
                const randomButton = document.getElementById('random-button');
                randomButton.textContent = "Character Complete";
                randomButton.classList.remove('active');
                randomButton.disabled = true;
                randomButton.style.opacity = "0.6";
                randomButton.style.cursor = "not-allowed";
                randomButton.style.backgroundColor = "#95a5a6"; // Gray color
                
                // Stop random generation if it's running
                if (isRandomGenerating) {
                    isRandomGenerating = false;
                    // Instead of calling stopRandomGeneration, do the actions inline
                    if (randomTimer) {
                        clearTimeout(randomTimer);
                        randomTimer = null;
                    }
                    
                    const randomButton = document.getElementById('random-button');
                    if (randomButton) {
                        randomButton.textContent = "Auto-Random";
                        randomButton.classList.remove('active');
                    }
                    
                    console.log("Random generation stopped inline");
                }
            }
            
            // Check if this completion completes all groups
            const allGroupsNowComplete = Object.keys(paramGroups).every(id => completedParams[id]);
            
            // Fix: Loop through all groups to ensure we can access completed groups' parameters
            for (let grpNum = 1; grpNum <= 4; grpNum++) {
                const grpButton = document.getElementById(`group-${grpNum}`);
                if (grpButton && grpButton.classList.contains('completed')) {
                    // This group is completed, make sure its parameters are still accessible
                    const group = taxonomyData[grpNum];
                    if (group && group.parameters) {
                        group.parameters.forEach(param => {
                            const paramId = param.id;
                            if (completedParams[paramId]) {
                                // Re-enable this parameter for editing if it was disabled by rules
                                const paramElement = document.getElementById(`parameter-${paramId}`);
                                if (paramElement && paramElement.classList.contains('disabled-parameter')) {
                                    paramElement.classList.remove('disabled-parameter');
                                    paramElement.style.opacity = '';
                                }
                            }
                        });
                    }
                }
            }
            
            // Make sure gender-specific parameters stay properly hidden/shown
            if (selections[1] !== undefined) {
                const genderOption = taxonomyData[1].parameters.find(p => p.id === 1).options[selections[1]];
                const selectedGender = genderOption.name.toLowerCase();
                handleFacialHairVisibility(selectedGender.includes('female'));
            }
        }

        // Function to toggle random character generation
        function toggleRandomGeneration() {
            // Check if character is complete (all 4 groups are completed)
            const allGroupsCompleted = [1, 2, 3, 4].every(groupNum => {
                const groupBtn = document.getElementById(`group-${groupNum}`);
                return groupBtn && groupBtn.classList.contains('completed');
            });
            
            if (allGroupsCompleted && !isRandomGenerating) {
                // Don't allow starting random generation when character is complete
                alert("Character is already complete. Reset to create a new random character.");
                return;
            }
            
            isRandomGenerating = !isRandomGenerating;
            const button = document.getElementById('random-button');
            
            if (isRandomGenerating) {
                button.textContent = "Stop Random";
                button.classList.add('active');
                startRandomGeneration();
            } else {
                button.textContent = "Auto-Random";
                button.classList.remove('active');
                stopRandomGeneration();
            }
        }

        // Start the random generation process
        function startRandomGeneration() {
            // Reset if everything is already completed
            const allCompleted = Object.keys(paramGroups).every(paramId => completedParams[paramId]);
            if (allCompleted) {
                // Reset selections and start from beginning
                resetAllSelections();
                currentRandomGroup = 1;
                currentParameterIndex = 0;
            } else {
                // Find first uncompleted parameter
                findNextUncompleted();
            }
            
            // Start the timer
            randomNext();
        }

        // Find the next uncompleted parameter
        function findNextUncompleted() {
            // Start from the current position
            for (let groupNum = currentRandomGroup; groupNum <= 4; groupNum++) {
                const group = taxonomyData[groupNum];
                if (!group || !group.parameters) continue;
                
                let startIndex = groupNum === currentRandomGroup ? currentParameterIndex : 0;
                for (let i = startIndex; i < group.parameters.length; i++) {
                    const param = group.parameters[i];
                    if (!completedParams[param.id]) {
                        currentRandomGroup = groupNum;
                        currentParameterIndex = i;
                        return;
                    }
                }
            }
            
            // If we get here, everything is complete - restart from beginning
            currentRandomGroup = 1;
            currentParameterIndex = 0;
        }

        // Function to safely stop random generation
        function stopRandomGeneration() {
            // Clear the timer if it exists
            if (randomTimer) {
                clearTimeout(randomTimer);
                randomTimer = null;
            }
            
            // Reset random generation state
            isRandomGenerating = false;
            
            // Update UI button if it exists
            const randomButton = document.getElementById('random-button');
            if (randomButton) {
                randomButton.textContent = "Auto-Random";
                randomButton.classList.remove('active');
            }
            
            console.log("Random generation stopped");
        }

        // Make sure these functions are available in the global scope
        window.toggleRandomGeneration = toggleRandomGeneration;
        window.startRandomGeneration = startRandomGeneration;
        window.stopRandomGeneration = stopRandomGeneration;
        window.findNextUncompleted = findNextUncompleted;
    </script>
</body>
</html>